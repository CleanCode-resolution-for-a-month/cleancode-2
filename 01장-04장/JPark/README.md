# 1장 깨끗한 코드

## 나쁜코드란 무엇인가?

좋은 코드를 얘기하려면 나쁜 코드에 대해 짚고 넘어가는 것이 좋을 것이다.

나는 나쁜코드 때문에 고생을 한적이 있다.

나쁜코드를 수정하는 것은 마치 한 곳만 잘못 건드려도 어떠한 곳이 문제가 될지 모르는 무시무시한 지뢰밭과 같다.

개발자라면 누구나 자신이 대충 짠 코드를 나중에 손보리라 다짐할 것이다.

하지만, 르블랑의 법칙을 잊지말자. 언제나 그렇듯, 나중은 결코 오지 않는다.

## 나쁜코드는 왜 나쁜가

나쁜 코드는 개발 속도를 떨어뜨리고 팀의 생산성을 바닥으로 내동댕이 친다.

처음부터 새로 코드를 짜면 괜찮을까?

애석하게도 기존 시스템에 가해지는 변경을 모두 따라잡으면서 새 시스템이 기존 시스템의 기능을 모두 지원하지 않는한 대체되지 않는다.

## 왜 코드는 이지경이 되었을까?

코드가 엉망이 되었다면 온갖 이유를 들이댈 수 있다.

하지만, 좋은 코드를 만드는 건 결국 프로그래머, 우리들이다.

올바르게 코드를 작성하는 마음가짐과 기한에 쫓겨 서둘러 키보드를 타이핑하려는 자신 사이에서 갈등한적이 있는가?

근시안적인 사고라면 그렇게 생각한다. 멀리보라. 

나쁜 코드는 기한을 늦출 뿐이다.

기한을 맞추는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 습관이다.

## 고수들이 말하는 깨끗한 코드란?

나는 C++ 창시자 비야네 스트롭스트룹의 클린코드 정의를 가장 좋아한다. 

이 정의는 더 더할 것이 없고 더 덜어낼 것이 없는 클린코드의 핵심 그 자체를 설명한다.

> I like my code to be elegant and efficient. 
The logic should be straightforward to make it hard for bugs
to hide, the dependencies minimal to ease maintenance, error handling complete according to an articulated strategy, and performance close to optimal so as not to tempt people to make the code messy with unprincipled optimizations. Clean code does one thing well.
- Bjarne Stroustrup
> 

비야네의 ‘elegant(우아한)’은 보기에 좋은 코드다. 깨끗한 코드란 보기에 좋으며 곧 우아하다.

클린 코드는 한가지 일을 제대로 한다. 

한 가지일을 하는 것은 객체지향 설계 원칙(SOLID)의 Single Responsibility 와 일맥상통한다.

셰익스피어가 말했듯, 간결함은 지혜의 핵심이다.

---

# 2장 의미 있는 이름

클린코드를 진입하는 첫번째 관문은 변수다.

변수는 단순히 정수형이나 객체의 이름에만 한정되지 않는다.

패키지 이름이나 소스 파일의 디렉토리, war 파일의 이름도 모두 변수다.

이름을 잘 짓기 위해서 어떤 규칙이 있을까?

## 말하고자 하는 바를 정확히 설명하기

변수 하나만 보고도 모든 의미가 와닿아야 한다.

변수 이름은 직관적이여야 한다는 것이다.

또한, if 절에 사용되는 표현절을 메소드로 리팩토링해보라.

더욱 의도가 드러난다.

예를 들어,

```java
if (cell(STATUS_VALUE] == FLAGGED)
```

보다

```java
if (cell.isFlagged())
```

가 더 의도를 드러내는 코드다.

## 반대로, 변수에 드러내선 안되는 정보

실제 List가 아니면 accountList라 명명하지 마라

실제 자료구조 유형 이름을 변수에다 쓰지 않는 것이 바람직하다.

서로 흡사한 이름을 쓰지마라

변수는 대충보아도 뚜렷히 구분돼야 한다.

나는 UserInfo와 같이 어떤것의Info 와 같은 형식의 네이밍을 하는 경우가 많았다.

Info는 a나 the 처럼 의미가 없는 불용어다. 

한국 개발자는 한정사 a나 the를 사용하는 경우는 잘 없지만, Info와 같은 의미가 없는 접두어를 작성하는 경우가 종종있다.

## 인터페이스 네이밍에서 사람들이 자주 사용하는 잘못된 패턴

도형을 생성하는 클래스의 이름을 ShapeFactory라고 했을 때, 이 클래스의 인터페이스 이름을 IShapeFactory라고 짓는 개발자들이 많다.

인터페이스 이름은 접두어를 붙이지 않는 것이 좋다.

인터페이스의 목적은 구체적인 사항을 숨기는 것이다. 

추상화된 코드를 사용하는 개발자는 표면적으로 인터페이스를 사용한다는 것을 아는 것은 좋지 않다.

차라리 구현 클래스의 이름을 달리하는 것이 좋다. 예를 들어, ShapeFactoryImpl 같은 것이다.

왜냐하면 구현 클래스는 인터페이스 뒤에 숨겨져 있으므로, 인터페이스를 사용하는 사람이 알지 못하기 때문이다.

## 맥락이 부여된 이름

어떤 메서드가 state라는 이름을 갖는다면 이 변수가 상태를 의미하는지, 주소를 의미하는지 단번에 알 수 있을까?

의미있는 맥락을 추가해 addrState 라 쓰면 맥락이 더 분명해진다.

하지만 책의 저자와 다르게, 나는 변수의 이름은 객체의 이름에서 다시 중복해서 작성하지 않는다.

여기에는 두 가지 이유가 있다. 

하나의 객체에서 한정된 영역에서 다시 설명되는 것이기 때문이다.

## 가장 중요한 것은 일관성이다.

일관성이 보장된다면, 패턴에 의거해 의미를 단번에 파악할 수 있다.

숫자를 더하는 메소드를 add라고 명명한 코드가 있다고하자.

그런데 컬렉션에 원소를 더하는 메소드 또한 add 라고 명명한다면 의미가 맞다고 해도 헷갈릴 것이다.

반대로, 위에서 언급한 인터페이스 네이밍을 I 접두사를 붙여 코드를 작성했다고 하더라도 코드 전반에 걸쳐 이러한 형식으로 네이밍을 했다면 코드를 읽는 것은 그리 어렵지 않다.

---

# 3장 함수

함수는 프로그램 내부를 감싼다.

따라서 함수를 들여다보면 감춰진 알고리즘이 보인다.

읽기 쉽고 이해하기 어렵지 않은 함수를 어떻게 작성해야할까?

## 작게 쪼개어라

함수를 작게 작성하는 것은 가장 일반적인 클린코드 원칙중 하나다.

그런데, 함수를 얼마나 작게 쪼개야 할까? 

작다는 것은 어느 정도 일까?

회원 정보 페이지를 HTML로 반환하는 작업을 수행하는 함수가 있다고 하자.

- 이 함수는 보여줄 회원의 ID를 받는다.
- 회원 ID를 이용하여 회원 정보를 가져온다.
- 회원 정보를 화면에 맞게 HTML로 반환한다.

위의 함수는 얼핏보면 3가지 일을 하는 것 같다.

```java
public String renderUserHtml(int userId) {
    User user = getUser(userId);
    return getHtml(user);
}
```

위와 같이 코드를 작성한다면 getUser 함수는 더 이상 추상화될 수 없다

getHtml 은 사용자(User) 정보 없이 사용될 수 없다.

만약 renderUserHtml 함수가 userId 대신 User를 받는다면 getHtml 를 사용하는 것과 별다른 의미가 없다.

추상화된 메소드가 서로 모여 새로운 의미를 만든다면 한가지 일을 한다고 볼 수 있다.

가장 좋은 방법은 메소드 이름을 작성할때 하나의 일을 하는 것으로 드러나는 가를 확인하는 것이다.

## 이야기를 들려주는 것처럼 읽히는 코드

누군가가 함수의 동작에 대해 읽어주는 것처럼 코드를 위에서 아래로 읽어내려갈 때 이야기처럼 들려야 한다.

이름이 길어지면 이상하지 않을까? 차라리 이름이 긴 것이 파악하기 어렵고 모호하게 만든 이름보다 낫다.

## 함수의 파라미터는 2개 이하로!

함수의 인수의 수가 적을 수록 좋다.

함수에 인수 1개를 넘기는 메소드는 대부분 질문을 던지는 메소드다.

boolean fileExists(”MyFile”) 과 같은 예가 있다.

다른 하나는 인수를 다른 것으로 바꿔 반환하는 경우가 있다.

InputStream fileOpen(”MyFile”) 은 String 형의 파일 이름을 InputStream으로 변환한다.

인수가 2개만 되어도 복잡도가 올라간다.

가장 유명한 예가 테스트 코드에서 사용되는 단언문이다.

assertEquals(expected, actual)이 있다. 

expected와 actual을 바꿔 넣는 실수는 누구나 해보았을 것이다.

AssertJ는 이러한 문제점을 해결하기 위해, 메서드 체이닝 방식을 사용한다.

```java
assertThat(helloWorld)
    .isNotNull()
    .isNotEmpty()
    .startsWith("Hello ")
    .contains(" ")
    .contains("World")
    .endsWith("!")
    .doesNotStartWith("World")
    .doesNotContain("--")
    .doesNotEndWith("Hello");
```

함수가 3개를 넘어가는 것을 피하라는 말만 하지말고, 해결책을 들려주어야겠다.

인수 여럿을 의미 단위를 갖는 객체로 감싸라

예를 들어, 네트워크 통신을 수행하는 함수에 필요한 것이 다음과 같이 3가지 인수일 경우, ip와 port를 서로 의미 단위로 묶을 수 있다.

```java
// bad 😌
Connection connect(String ip, String port, int timeout); 
// good 😊 
Connection connect(IPAddress ipaddress, int timeout);
```

## 남몰래 저지르는 거짓말, 부수효과(Side Effect)

부수효과는 코드를 읽는 사람이 모르게 전역 변수를 수정한다.

사람이 예측하는 대로 코드가 수행되는 것이 클린코드다.

부수효과의 가장 큰 문제는 단순 가독성이 아니다.

버그가 발생했을 때 어디서 문제점이 발생했는지 알기가 어렵다는 것이다.

이 경우 소스 코드 전역 검색을 통해 사태를 해결해야 한다.

전역 검색을 한다는 것은 곧 코드가 짜임새 있지 못하다는 것을 방증한다.

아웃 파라미터(출력 인수) 역시 부수효과다.

읽는이는 출력 인수의 값이 바뀌리라 쉽게 인지하지 못한다.

다음 메소드의 list는 아웃파라미터다.

add라는 메소드 의미를 통해 list에 숫자(number)가 들어갈 수 있음을 짐작 할 수 있는가?

```java
class MyList {
    void add(List<Integer> list, int number);
}
```

만약 list와 number가 모두 MyList 객체에 add 되는 것이라면?

의미가 모호해지면 곧 나쁜코드다.

아래 메소드처럼 인자가 의심의 여지 없이 해당 클래스에 추가된다는 것을 말해줘야 한다.

```java
class MyList {
    void add(int number);
}
```

## 오류에는 예외를 바로 던져라 그리고 그 뒷처리는 한곳에서 하라

블럭 단위가 깊어지면 깊어질 수록 코드는 지저분해진다.

Try/Catch 구문을 사용하는 개발자들에게서 많이 보이는 실수 중 하나가 예외를 한곳에서 처리하지 않는다는 것이다.

Try/Catch 는 블럭 단위를 만든다. 

또한, 코드 구조에 혼란을 주며 정상적인 동작과 오류 처리 동작이 하나의 함수에 혼재된다.

---

# 4장 주석

프로그래밍 언어를 오차없이 의도를 표현한다면 주석은 전혀 필요없다.

하지만, 코드로는 모두 표현되지 않는 것들을 보완하기 위해 주석을 사용한다.

주석이 나쁜 이유는 코드가 될 수 없기 때문이다.

주석은 코드와 항상 동기화되지 못한다. 코드가 변경될 때마다 주석 또한 고쳐야 된다. 

그럴만한 부단한 노력이 없다면 잘못된 정보를 주는 것 따위는 차라리 없는게 도움이 된다.

코드만이 정확한 정보를 제공하는 유일한 출처다.

코드가 곧 문서다. 

문서화를 하지 마라는 것이 아니다.

숲을 보기 위한 아키텍처 설명이나 데이터 흐름과 같이 총체적인 의미의 문서는 필요하다.

주석이 필요한 경우는 이유 자체를 코드에 담는 경우다.

만약 테스트 메소드에서 의미 없어보이는 인스턴스 생성을 하는 것은 이유를 파악해야 코드의 의도를 알 수 있다.

```java
// 스레드를 대량 생성하여 경쟁조건을 만든다.
for (int i = 0; i < 25000; i++) {
    Thread thread = new Thread(new MyThread());
    thread.start();
}
```

내가 자주 작성하는 주석은 TODO 주석이다.

당장에 처리하기 어렵지만 이후 처리가 돼야하는 것을 주석에 담으면 추후에 코드를 보았을 때 해당 지점에서 상기시켜준다.

클린코드 책은 잘못된 주석의 예제들이 다양하게 제시한다.

모든 문제의 원인은 코드만으로 동작을 명확히 설명하지 못하기 때문이다.

클린코드의 원칙들을 따르다 보면 주석은 자연스럽게 필요없어지게 될 것이다.


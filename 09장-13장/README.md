# 9장 단위테스트

90년대 이전의 단위 테스트

- 나의 프로그램이 ‘구동된다’ 라는 사실만 확인하는 일회성 코드
- 대개는 간단한 드라이버 프로그램으로 자신이 짠 프로그램을 수동으로 실행하여 테스트

현재의 단위 테스트

- 테스트 케이스를 모두 구현하고 통과해야 내 코드를 공개함
- 테스트 코드와 내 코드를 같은 소스 패키지로 묶어서 커밋

## TDD의 3가지 법칙

1. 실패하는 단위 테스트를 작성하기 전까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 실패하는 테스트를 통과할 실제 코드를 작성한다.

위 3 단계 주기는 30초 정도다.

이렇게 매일 진행하면 수십개의 테스트 케이스를 만들어 낼 수 있다.

하지만 테스트 코드 **역시 우리가 직접 관리해야할 소스 코드다.**

따라서 깨끗하게 테스트 코드를 유지하는 것이 중요하다.

## 테스트 코드를 깨끗하게 유지하기

프로그램을 작성하면서 새로운 패치를 출시할 때마다 테스트 케이스를 유지하고 보수하는 비용이 늘어난다.

테스트 코드를 폐기할 수 밖에 없을까?

하지만 테스트 코드가 없으면 프로그램의 오류 발생률은 높아질 것이다.

**테스트 코드가 문제가 아니라 깨끗한 테스트 코드를 만들지 않을 것이 문제다.**

테스트 코드는 실제 코드와 같은 중요도를 갖는다.

## 가독성이 깨끗한 테스트 코드의 전부다.

실제 프로덕션 코드의 클린 코드 원칙은 테스트 코드에도 그대로 적용된다.

코드를 읽기 이해하기 쉬워야 된다.

## 테스트 작성 방법

### 테스트당 단언문(assert) 는 1개로만 유지하도록 한다.

테스트 케이스 함수 하나에 단언문(assert)를 하나만 사용하는 것이 좋다.

하지만, 여러 함수를 나누다보면 중복이 많아지는 것은 필연적이다.

따라서, 단언문을 여러번 사용하는 것이 때로는 좋지만 가능한 1개로만 유지한다.

### F.I.R.S.T (빠르게, 독립적으로, 반복가능하게, 자가검증하는, 적시에)

깨끗한 테스트 코드 규칙을 간단하게 FIRST라는 한 단어로 설명할 수 있다.

- Fast: 테스트는 빨라야 한다. 1초가 넘는 테스트 코드를 최적화하라
- Independent: 테스트와 테스트는 서로 의존하면 안되낟. 테스트가 시작할 때 환경은 깨끗하게 청소돼야 한다.
- Repetable: 테스트는 어떤 환경에서도 반복 실행할 수 있어야 한다.
- Self-Validating: 테스트 결과 성공이 아니면 실패다. 테스트 결과에 대해 주관적으로 해석되면 안된다.
- Timely: 시의적절하게 작성해야 한다. 실제 코드를 작성하기 전에 단위 테스트를 작성하라.

---
# 10장 클래스

이전 장까지는 메서드에 한정하여 클린코드를 설명하였다.

## 클래스 체계

클래스는 작아야 한다

- 클래스의 크기는 클래스가 맡은 책임을 기준으로 한다.

메서드가 적지만 많은 책임을 클래스

```java
public class SuperDashboard extends JFrame implements MetaDataUser {
  public Component getLastFocusedComponent()
  public void setLastFocused(Component lastFocused)
  public int getMajorVersionNumber();
  public int getMinorVersionNumber();
  public int getBuildNumber();
}
```

클래스 이름부터 보자, 클래스 이름에서 해당 클래스의 책임을 알 수 있다.

클래스 SuperDashboard는 이름이 애매모호하다.

단일 책임 원칙(Single Responsibility Principle)

단익 책임 원칙, SRP는 클래스의 책임 하나로 한정지을 것을 말한다.

위 SuperDashboard 클래스는 책임이 하나인가?

- 소프트웨어 버전 정보가 바뀌면 변경된다.
- 버전 정보가 달라질때마다 수정된다.
- 또한, GUI를 관리한다.

먼저 버전 정보를 별도의 클래스로 관리하자

```java
public class Version {
  public int getMajorVersionNumber();
  public int getMinorVersionNumber();
  public int getBuildNumber();
}
```

적은 개수의 큰 클래스보다 작은 클래스가 많은것이 SRP에 부합한다.

응집도, 클래스의 메서드와 변수가 서로 의존해야 한다.

다음 클래스 Stack은 응집도가 높다고 말할 수 있다.

모든 함수가 필드에 접근하여 사용하고 있기 때문이다.

```java
public class Stack {
  private int topOfStack = 0;
  List<Integer> elements = new LinkedList<Integer>();

  public int size() {
    return topOfStack;
  }
  public void push(int element) {
    topOfStack++;
    elements.add(element);
  }
  
  public int pop() throws PoppedWhenEmpty {
    if (topOfStack == 0)
      throw new PoppedWhenEmpty();
    int element = elements.get(--topOfStack);
    elements.remove(topOfStack);
    return element;
  }
}
```

## 변경에도 취약하지 않는 시스템

구체적인(concret) 클래스는 상세한 구현을 갖는다.

상세한 구현에 의존하는 클래스는 위험에 취약해진다.

다음처럼 인터페이스를 생성하여 인터페이스를 통해 의존하도록 하라

```java
public interface StockExchange {
  Money currentPrice(String symbol);
}

// 이 코드는 인터페이스에 의존한다.
public Portfolio {
  private StockExchange exchange;
  public Portfolio(StockExchange exchange) {
    this.exchange = exchange;
  }
}
```

이처럼 구체적이지 않은 추상적인 클래스에 의존하면 테스트를 작성하기도 쉬워진다.

다음은 Portfolio 클래스를 테스트하는 예제에서 Stub을 사용하여 가짜 객체를 사용한 예제다.

```java
public class PortfolioTest {
  private FixedStockExchangeStub exchange;
  private Portfolio portfolio;
  
  @Before
  protected void setUp() {
    exchange = new FixedStockExchangeStub();
    exchange.fix("MSFT", 100);
    portfolio = new Portfolio(exchange);
  }
  
   @Test
   void GivenFiveMSFTTotalShouldBe500() throws Exception {
     protfolio.add(5, "MSFT");
     assertEquals(500, portfolio.value());
   }
}
```

결합도를 최소한으로 줄였을 때 얻는 또다른 이점은 무엇일까?

DIP(의존성 역전 원칙)에 부합하는 클래스가 된다.

DIP는 클래스가 상세한 구현이 아닌 추상화에 의존하는 원칙을 말한다.

위 Portfolio 클래스는 더 구체적인 클래스인 TokyoStockExchange나 SeoulStockExchange 가 아닌, StockExchange 인터페이스에 의존하여 구체적인 사실을 알지 못한다.

# 11장 시스템

도시와 시스템의 공통점

| 도시 | 시스템 |
| --- | --- |
| 세세한 사항을 혼자 관리할 수 없음 | 하나의 시스템을 혼자 개발할 수 없음 |
| 수도 관리 팀, 전력 관리 팀 등 각 분야를 관리하는 팀이 있음 | 각 모듈을 개발하고 관리하는 팀이 있음 |

## 시스템 제작과 시스템 사용을 분리하라

- 제작 construction: 애플리케이션 객체를 제작하고 의존성을 서로 연결하는 단계
- 사용 use: 런타임 로직

대다수의 애플리케이션의 문제점은?

관심사를 분리하지 않는다는 것이다.

즉, 런타임 로직과 준비 과정 코드를 마구 뒤섞는다.

```java
public Service getService() {
  if (service == null)
    service = new MyServiceImpl();
  return service;
}
```

위 코드는 객체를 생성하는 런타임 로직이다.

getService() 메서드가 특정한 MyServiceImpl 이라는 구현체에 의존한다.

또한, 위 코드는 단일 책임 원칙을 위반한다.

일반 런타임 로직에 객체 생성 로직을 뒤섞었기 때문이다.

## 시스템 생성과 시스템 사용을 분리하는 방법 1 - Main 분리

시스템 생성과 시스템 사용을 분리하는 한가지 방법은 main을 분리하는 것이다.

생성을 책임지는 코드는 main 메서드(진입 메서드)에서 수행한다.

main의 시스템 사용 흐름

1. main 에서 시스템에 필요한 객체를 생성한다.
2. main은 시스템 애플리케이션에 이 객체를 넘긴다.
3. 애플리케이션은 이 객체를 사용한다.

## 시스템 생성과 시스템 사용을 분리하는 방법 2 - 팩토리

main을 분리하는 방법은 컴파일 시점에 객체가 정해진다.

반대로 객체 생성 시점을 애플리케이션이 결정해야할 때가 있다.

추상 팩토리(ABSTRACT FACTORY) 패턴을 사용한다.

main 메서드에서 Interface Factory를 구현하면

애플리케이션은 main 메서드에서 구현된 Factory를 그대로 사용할 수 있다.

의존성은 어디로 향할까?

여전히 main에서 애플리케이션으로 향한다.

왜냐하면 Factory를 사용하는 애플리케이션은 구현체를 모른다. 

다만 인터페이스를 의존할 뿐이다.

## 시스템 생성과 시스템 사용을 분리하는 방법 3 - DI

DI(Dependency Injection)은 사용과 제작을 분리하는 가장 강력한 메커니즘 중 하나다.

의존성 자체를 인스턴스로 만드는 책임을 지지 않는다.

대신, 이러한 의존성을 만드는 작업을 main과 같은 컨테이너에 넘긴다.

DI의 예는 JNDI가 있다.

다음은 의존성 주입을 사용하는 예제다.

```java
MyService myService = (MyService) (jndiContext.lookup("NameOfMyService"));
```

스프링 프레임워크는 DI 컨테이너의 표본이다.

## 횡단 관심사

영속성과 같은 관심사는 애플리케이션의 객체 경계를 넘나든다.

모든 비즈니스 객체가 동일한 코드를 사용해야 한다는 의미다.

트랜잭션을 시작하고(begin transaction), 커밋(commit)해야하는 코드가 그 예다.

영속성을 구현한 코드를 모듈화하기 위해 횡단 관심사라는 개념이 탄생했다.

AOP(Aspect-Oriented Programming)은 관점 지향 프로그래밍이다.

## AOP 메커니즘 1 - 자바 프록시

단순한 상황에 적합

개별 객체나 클래스의 메서드 호출을 감싸는 경우

클래스 프록시는 CGLIB, ASM, Javaassist와 같은 바이트 코드 라이브러리가 필요하다.

프록시는 인터페이스와 비즈니스 로직 구현체인 POJO를 사용한다.

## AOP 메커니즘 2 - 순수 자바 AOP 프레임워크

스프링 AOP는 순수 자바 관점을 구현하기 위해 내부적으로 프록시를 사용한다.

스프링은 순수하게 도메인에 초점을 맞춘 객체인 POJO를 사용한다.

스프링 관련 자바 코드가 필요 없으므로 애플리케이션은 스프링과 독립적이다.

EJB2 시스템이 지닌 강한 결합의 문제점을 해결해냈다.

EJB3는 스프링 프레임워크의 영감을 이어 받아 애노테이션 기능을 사용하여 횡단 관심사를 선언적으로 지원한다.

## AOP 메커니즘 3 - AspectJ 언어

관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ 언어다.

스프링 AOP가 제공하는 순수 자바 방식은 대부분 90%의 상황에 들어맞는다.

## TDD로 아키텍처 구축이 가능할까?

관심사를 분리하는 방식, 애플리케이션 도메인 논리를 POJO로 작성한다면 테스트 주도 아키텍처 구축이 가능하다.

구현을 시작하기 전에 앞으로 벌어질 상황에 대해 모든 사항을 설계하는 **BDUF**를 추구하지 않아도 된다.

세계 최대 웹 사이트들은 고도이 캐싱, 보안, 가사황을 사용하여 가용성과 성능을 최고로 끌어올릴 수 있었던 이유가 무엇일까?

관심사 분리를 성공했기 때문이다.

지금까지 한 이야기의 요약

> 최선의 시스템 구조는 POJO 객체로 구현된 모듈화된 관심사 도메인으로 구성된다.
서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다.
이런 구조를 사용하면 테스트 주도 기법을 사용할 수 있다.
>

---

# 12장 창발성

***창발***(創發) 또는 떠오름 현상은 하위 계층(구성 요소)에는 없는 특성이나 행동이 상위 계층(전체 구조)에서 자발
으로 돌연히 출현하는 현상이다.([https://ko.wikipedia.org/wiki/창발](https://ko.wikipedia.org/wiki/%EC%B0%BD%EB%B0%9C))

착실하게 따르기만 하면 우수한 설계가 나오는 간단 규칙 네가지

1. 모든 테스트를 실행한다
2. 중복을 없앤다
3. 프로그래머 의도를 표현한다
4. 클래스와 메서드 수를 최소로 한다

## 규칙1. 모든 테스트를 실행한다

생각한 의도대로 시스템이 돌아가는지 확인하려면?

문서를 쓴다? ❌

문서작성은 코드와 동기화가 어렵다

테스트를 한다! ⭕️

모든 테스트 케이스를 항상 통과하는 시스템을 만들면 설계 품질을 높일 수 있다.

결합도가 높으면 테스트 케이스를 작성하기 어렵다. 

테스트 케이스를 많이 작성할 수록 DIP, 인터페이스, 추상화 등과 같은 도구를 사용해 결합도가 낮아진다.

## 규칙2-3. 리팩터링

테스트 케이스를 작성하고나면 코드를 점진적으로 리팩터링해야 한다.

왜 리팩터링보다 테스트 케이스가 먼저일까?

테스트 케이스가 있다면 코드를 정리하면서 시스템이 깨질 염려가 없다.

중복을 줄이는 것은 가장 손쉬운 리팩터링 방법이다.

```java
int size() {}
boolean isEmpty() {}

boolean isEmpty() {
  return 0 == size();
}
```

위 코드는 isEmpty() 메서드가 다른 메서드를 다시 재사용하여 중복을 줄였다.

## 표현을 잘하는 방법

소프트웨어 프로젝트는 대부분 장기 유지보수를 한다.

코드를 변경하면서 버그를 양산하지 않으려면 유지보수 개발자가 시스템을 정확히 이해해야 한다.

하지만, 시스템은 복잡해지고 개발자는 시스템을 이해하기 위한 시간이 걸린다.

개발자는 코드를 분명하게 표현해야 한다.

- 좋은 이름을 사용하라
- 함수와 클래스의 크기를 가능한 작게 한다.
- 표준명칭을 사용한다. (디자인 패턴이 있을 경우 클래스 이름에 표기한다.)
- 단위 테스트를 꼼꼼히 작성한다.
- 코드를 쉽게 만들기 위한 노력을 기울여라

## 클래스와 메서드 수를 최소로 유지하라

SRP와 같은 객체지향 규칙이 먼저일까? 아니면, 규칙을 어기더라도 실용적인 것이 좋을까?

독단적인 견해보다 실용적인 방식을 택하라.

클래스 수와 메서드수가 많아진다면 클래스마다 인터페이스를 생성할 필요는 없다.

---

# 13장 동시성

동시성과 읽기 쉬운 코드는 양립하기 어렵다.

동시성이 필요한 이유는?

여러 스레드를 동시에 돌려야하는 이유는?

여러 스레드를 동시에 돌리는 것은 왜 어려울까?

## 동시성이 필요한 이유?

동시성은 결합(coupling)을 없애는 전략이다.

동시성은 무엇과 언제를 분리한다.

가장 대표적인 동시성의 예는 서블릿(Servlet)이다.

서블릿 컨테이너는 동시성을 부분적으로 관리한다.

클라이언트가 웹 요청을 하면 웹 서버는 비동기로 서블릿을 실행한다.

프로그래머는 웹 요청 동시성을 다룰 필요가 없다.

서블릿 컨테이너가 완전히 결합을 없애는 전략일까?

응답 시간과 작업 처리량(throughput) 을 개선하려면 동시성 구현을 직접적으로 해야 한다.

예를 들어, 여러 웹사이트를 크롤링하는 수집기는 웹 사이트가 추가되어도 시간은 차이가 없어야 한다.

## 동시성에 대한 오해

동시성은 항상 성능을 높여준다?

동시성이 항상 성능을 높여주지는 않는다.

동시성을 구현해도 설계는 변하지 않는다?

단일 스레드 시스템과 다중 스레드 시스템은 설계가 다르다.

무엇과 언제를 분리하면 프로그래밍도 달라진다.

웹 또는 서블릿 컨테이너를 사용하면 동시성을 이해하지 않아도 코딩할 수 있다?

컨테이너의 동작 원리, 동시 수정, 데드락 등을 이해해야 한다.

## 동시성이 어려운 이유?

```java
public class X {
  private int lastIdUsed;

  public int getNextId() {
    return ++lastIdUsed;
  }
}
```

인스턴스 X를 생성하고 lastIdUsed 필드가 42라면,

두 스레드가 동일한 인스턴스를 사용한다고 했을 때, getNextId() 메서드를 호출한다고 하자.

- A Thread ⇒ 43, B Thread ⇒ 44, lastIdUsed = 44
- A Thread ⇒ 43, B Thread ⇒ 44, lastIdUsed = 44
- A Thread ⇒ 43, B Thread ⇒ 43, lastIdUsed = 43

결과는 세번째가 된다.

단순히 코드 한줄을 실행하더라도 JVM 내부적으로 여러 일이 발생한다.

JIT 컴파일러가 바이트 코드를 처리하는 방식과 자바 메모리 모델이 원자로 간주하는 최소 단위가 다르다.

바이트 코드레벨에서 보면, 두 스레드가 getNextId 메서드를 실행하는 경로는 12,870개다.

lastUsed 변수가 int에서 long으로 변경되면 경로의 경우의 수는 약 2백 7십만개가 된다.

## 동시성을 제어하는 방법

### 단일 책임원칙(SRP)

SRP는 메서드, 클래스, 컴포넌트를 변경하는 이유가 한 가지여야 한다는 원칙이다.

동시성 관련 코드는 다른 코드와 분리하는 것이 맞다.

동시성을 구현할 때는 다음을 고려해라.

- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있어야 한다.
- 동시성 코드는 일반적 코드와 다른 어려움이 있다.
- 잘못 구현한 동시성 코드는 다양한 방식으로 인해 실패한다.

따라서, 동시성 코드는 다른 코드와 분리해야 한다.

### 자료 범위를 제한하라

두 스레드가 서로 객체 하나를 동시에 수정하려 한다면 예상치 못한 결과를 만든다.

이런 문제를 해결하기 위해 코드의 임계영역(critical section)인 synchronized 키워드를 사용해야 한다.

### 자료를 공유하지 말고 복사해라

자료 공유로인해 발생하는 문제를 일으키지 않으려면, 공유를 하지 않는 것이 가장 좋다.

객체를 복사하여 읽기 전용으로 사용하도록 하라.

하지만, 사본 생성과 가비지 컬렉션에 드는 부하를 잘 고려해야한다.

### 스레드는 독립적으로 구현해라

각 스레드는 클라이언트 요청 하나를 처리해야 한다.

마치 스레드는 세상에 자신만 있는 듯이 돌아가야 한다.

서블릿 스펙인 HttpServlet 클래스에서 파생한 클래스는 모두 doGet()과 doPost() 매개변수로부터 받는다.

그래서 각 서블릿은 마치 자신이 독자적인 시스템에서 동작하는 것처럼 처리할 수 있다.

서블릿 코드가 로컬 변수만 사용한다면 서블릿의 동기화 문제는 발생하지 않는다.

하지만, 데이터베이스 연결 자료를 공유해야할 수 밖에 없다.

### 라이브러리를 제대로 이해하라

자바 5이후의 동시성 기능이 개선이 되었다.

자바 5로 스레드를 구현한다면 다음을 고려해라

- 스레드 환경에 안전한 컬렉션을 사용하라

```java
Collection<Integer> syncCollection = Collections.synchronizedCollection(new ArrayList<>());
```

- executor 프레임 워크를 사용하여 서로 무관한 작업을 수행하도록 하라
- 가능하다면 스레드가 차단 되지 않도록 하라
- 일부 클래스 라이브러리는 스레드에 안전하지 못하다.

### 스레드 환경에 안전한 컬렉션

자바 java.util.concurrent 패키지를 사용하라.

이 패키지가 제공하는 클래스인 ConcurrentHashMap은 HashMap보다 월등하다.

## 다중 실행 모델

### 생산자-소비자(Producer-Consumer)

하나 이상 생산자 스레드가 버퍼나 큐에 데이터를 넣는다.

하나 이상 소비자 스레드가 대기열(버퍼, 큐)에서 정보를 가져와 사용한다.

여기서 대기열은 **한정된 자원**이다.

생상자 스레드와 소비자 스레드는 서로에게 시그널을 보낸다.

생산자 스레드는 대기열에 정보를 채우고 소비자 스레드에게 대기열에 정보가 있음을 알린다.

### 읽기-쓰기(Readers-Writers)

읽기 스레드는 공유 자원을 사용한다.

쓰기 스레드는 이 공유 자원을 가끔씩만 사용한다.

이 경우 처리율이 저하될 수 있다.

### 식사하는 철학자들(Dining Philosophers)

둥근 식탁에 철학자 여럿이 앉아있다.

철학자는 각자 왼쪽에 포크를 놓는다.

커다란 스파게티 한접시가 식탁에 놓여있다.

철학자는 배가 고플때 양손에 포크를 집고 스파케티를 먹는다. 

양손에 포크를 못쥐면 먹지 못한다.

왼쪽이나 오른쪽 철학자가 포크를 사용한다면 기다려야 한다.

철학자는 스레드로, 포크를 자원으로 치환하여 볼 수 있다.

## 스레드 코드 테스트하기

스레드 코드 테스트는 정확성을 완전히 보장하지 않지만, 스레드로 인한 위험도를 확연히 낮출 수 있다.

프로그램 설정과 부하를 변경하여 다양하게 자주 테스트를 구동해야 한다.

스레드 코드 테스트를 위한 지침

- 다중 스레드를 고려하지 않는 순차 코드부터 제대로 만들어라
- 말이 안되는 실패는 잠정적인 스레드 문제로 간주하라
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 놓도록 스레드를 구현하라
- 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정하라
- 프로세서 수보다 많은 스레드를 돌려보아라
- 다른 os에서 돌려보라
- 코드에 보조 코드를 넣어 돌려라

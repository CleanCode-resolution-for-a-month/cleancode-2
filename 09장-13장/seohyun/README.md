# 내용 요약

## 9장 단위 테스트

**TDD 법칙 세 가지**

1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하기 않으면서 실행히 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

규칙을 따르면 테스트 코드와 실제 코드가 함께 나올뿐더러 테스트 코드가 실제 코드보다 불과 몇 초 전에 나온다.  
이렇게 일하면 매일 수십 개에 달하는 테스트 케이스가 나오고, 실제 코드를 사실상 전부 테스트하는 테스트 케이스가 나온다. 하지만 실제 **코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발**하기도 한다.

### 깨끗한 테스트 코드 유지하기

실제 코드가 진화하면 테스트 코드도 변해야 한다. 그런데 테스트 코드가 지저분할수록 변경하기 어려워진다.

테스트 코드는 실제 코드 못지 않게 중요하다. 테스트 코드는 사고와 설계와 주의가 필요하므로 실제 코드 못지 않게 깨끗하게 짜야 한다.

### 테스트는 유연성, 유지보수성, 재사용성을 제공한다

테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 아키텍처가 아무리 유연하더라도, 설계를 아무리 잘 나눴더라도, 테스트 케이스가 없으면 개발자는 변경을 주저한다. 버그가 숨어들까 두렵기 때문이다.

### 깨끗한 테스트 코드

깨끗한 테스트 코드를 만드려면 -> 가독성 중요. (어쩌면 실제 코드보다 더더욱 중요하다.)  
테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다.

**BUILD-OPERATE-CHECK 패턴**

1. 테스트 자료를 만든다.
2. 테스트 자료를 조작한다.
3. 조작한 결과가 올바른지 확인한다.

### 이중 표준

테스트 API 코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 다르다. 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다.

### F.I.R.S.T

깨끗한 테스트는 다섯 가지 규칙을 따른다.

- **Fast(빠르게)**: 테스트는 빨라야 한다. 테스트가 느리면 자주 돌릴 엄두를 못 낸다.
- **Independent(독립적으로)**: 각 테스트는 서로 의존하면 안 된다. 각 테스트는 독립적으로, 어떤 순서로 실행해도 괜찮아야 한다. 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지고 후반 테스트가 찾아내야 할 결함이 숨겨진다.
- **Repeatable(반복가능하게)**: 테스트는 어떤 환경에서도 반복 가능해야 한다. 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다.
- **Self-Validating(자가검증하는)**: 테스트는 부울 값으로 결과를 내야 한다. 성공 아니면 실패다.
- **Timely(적시에)**: 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다.

---

## 10장 클래스

### 클래스는 작아야 한다!

**클래스는 작아야 한다.**

함수는 물리적인 행 수로 크기를 측정했다. 클래스는 클래스가 맡은 책임을 센다.

클래스 이름은 해당 클래스 책임을 기술해야 한다. 작명은 클래스 크기를 줄이는 첫 번째 관문이다. 간결한 이름이 떠오르지 않는다면, 클래스 이름이 모호하다면 클래스 크기가 너무 커서, 클래스 책임이 너무 많아서다.

클래스 설명은 "if", "and", "or", "but"을 사용하지 않고서 25단어 내외로 가능해야 한다.

### 단일 책임 원칙(Single Responsibility Principle, SRP)

클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다는 원칙이다.

자잘한 단일 책임 클래스가 많아지면 큰 그림을 이해하기 어려워진다는 개발자도 많다. 하지만 작은 클래스가 많은 시스템이든 큰 클래스가 몇 개뿐인 시스템이든 돌아가는 부품은 수가 비슷하다.  
규모가 어느 수준에 이르는 시스템은 논리가 많고도 복잡하므로, 이를 다루려면 체계적인 정리가 필수다.  
**큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이루어진 시스템이 더 바람직하다.**

### 응집도

일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다. 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높다.

응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미이다.

'함수를 작게, 매개변수 목록을 짧게'라는 전략을 따르다 보면 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다. 이는 새로운 클래스로 쪼개야 한다는 신호다. 응집도가 높아질수록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다.

### 변경하기 쉬운 클래스

**OCP(Open-Closed Principle)**: 확장에 개방적이고 수정에 폐쇄적이어야 한다는 원칙.

이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지는 않는다.

---

자바스크립트에서 상속이 필요한 경우라면 클래스를 사용하는 것이 좋다. 하지만 크고 복잡한 객체가 필요한 경우가 아니라면 클래스보다 작은 함수를 사용하자.

### 메소드 체이닝을 이용하세요

메소드 체이닝을 이용하면 간결하고 이해하기 쉽게 해준다.  
클래스 함수에서 단순히 모든 함수의 끝에 'this'를 리턴해주는 것으로 클래스 메소드를 추가로 연결할 수 있다.

```js
class Car {
  constructor() {
    this.make = "Honda";
    this.color = "Accord";
  }

  setMake(make) {
    this.make = make;
  }

  setColor(color) {
    this.color = color;
  }
}

const car = new Car();
car.setColor("pink");
car.setMake("Ford");
```

```js
class Car {
  constructor() {
    this.make = "Honda";
    this.color = "Accord";
  }

  setMake(make) {
    this.make = make;
    return this;
  }

  setColor(color) {
    this.color = color;
    return this;
  }
}

const car = new Car().setColor("pink").setMake("Ford");
```

---

## 11장 시스템

### 시스템 제작과 시스템 사용을 분리하라

제작과 사용은 아주 다르다는 사실을 명심한다.

소프트웨어 시스템은 준비 과정과 런타임 로직을 분리해야 한다.

```java
public Service getService() {
  if (service == null) service = new MyServiceImpl(...);
  return service;
}
```

이것이 초기화 지연 혹은 계산 지연이라는 기법이다.

장점

- 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않는다. -> 애플리케이션 시작 시간이 빨라진다.
- 어떤 경우에도 null 포인터를 반환하지 않는다.

단점

- getService 메서드가 MyServiceImpl과 생성자 인수에 명시적으로 의존한다. -> 런타임 로직에서 MyServiceImpl 객체를 전혀 사용하지 않아도 의존성을 해결하지 않으면 컴파일이 안 된다.
- MyServiceImpl이 무거운 객체라면 단위 테스트에서 적절한 테스트 전용 객체를 service 필드에 할당해야 한다.
- 일반 런타임 로직에다 객체 생성 로직을 섞어놓아 모든 실행 경로도 테스트해야 한다. -> 메서드가 작업을 두 가지 이상 수행.

체계적이고 탄탄한 시스템을 만들고 싶다면 손쉬운 기법으로 모듈성을 깨서는 안 된다.

### Main 분리

시스템 생성과 시스템 사용을 분리하는 한 가지 기법, 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.

애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모른다. 단지 모든 객체가 적절히 생성되었다고 가정한다.

### 테스트 주도 시스템 아키텍처 구축

코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다.  
BDUF(Big Design Up Front)를 추구할 필요가 없다. (BDUF: 구현을 시작하기 전에 앞으로 벌어질 모든 사항을 설계하는 기법.)  
BDUF는 처음에 쏟아 부은 노력을 버리지 않으려는 심리적 저항으로 인해, 처음 선택한 아키텍처가 향후 사고 방식에 미치는 영향으로 인해 변경을 쉽사리 수용하지 못한다.

시스템 역시 깨끗해야 한다. 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다. 도메인 논리가 흐려지면 제품 품질이 떨어진다. 기민성이 떨어지면 생산성이 낮아져 TDD가 제공하는 장점이 사라진다.

---

## 12장 창발성

**단순한 설계 규칙**

- 모든 테스트를 실행한다.
- 중복을 없앤다.
- 프로그래머 의도를 표현한다.
- 클래스와 메서드 수를 최소로 줄인다.

### 1: 모든 테스트를 실행하라

테스트가 불가능한 시스템은 검증도 불가능하다. 검증이 불가능한 시스템은 절대 출시하면 안 된다.

테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 더불어 높아진다. 테스트 케이스가 많을수록 개발자는 테스트가 쉽게 코드를 작성한다. 따라서 철저한 테스트가 가능한 시스템을 만들면 더 나은 설계가 얻어진다.

### 2~4: 리팩터링

테스트 케이스를 모두 작성했다면 코드를 점진적으로 리팩터링 해나간다.

테스트 케이스가 있기 때문에 코드를 정리하면서 시스템이 깨질까 걱정할 필요가 없다.

### 중복을 없애라

우수한 설계에서 중복은 커다란 적이다. 중복은 추가 작업, 추가 위험, 불필요한 복잡도를 뜻하기 때문이다.

### 표헌하라

표현력을 높이는 방법

1. 좋은 이름을 선택한다.
2. 함수와 클래스 크기를 가능한 줄인다.
3. 표준 명칭을 사용한다.
4. 단위 테스트 케이스를 꼼꼼히 작성한다. (테스트 케이스는 소위 예제로 보는 문서. 잘 만든 테스트 케이스를 읽어보면 클래스 기능이 한눈에 들어온다.)

가장 중요한 방법은 **노력**이다. 나중에 읽을 사람을 고려해 조금 이라도 쉽게 만들려는 고민을 하자.

### 클래스와 메서드 수를 최소로 줄여라

중복을 제거하고, 의도를 표현하고, SRP를 준수한다는 기본적인 개념도 극단으로 치닫으면 득보다 실이 많아진다.

목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있다.

---

## 13장 동시성

13장에서는 아래 4가지에 대해 논한다.

- 여러 스레드를 동시에 돌리는 이유
- 여러 스레드를 동시에 돌리는 어려움
- 어려움에 대처하고 깨끗한 코드를 작성하는 방법
- 동시성을 테스트하는 방법과 문제점

### 동시성이 필요한 이유?

동시성은 결합을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다. 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접해 호출 스택을 살펴보면 프로그램 상태가 곧바로 드러난다.

무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.

구조적 개선만을 위해 동시성을 채택하는 것은 아니다. 어떤 시스템은 응답 시간과 작업 처리량 개선이라는 요구사항으로 인해 직접적인 동시성 구현이 불가피하다.

### 미신과 오해

**미신**

- 동시성은 항상 성능을 높여준다. -> 동시성은 **때로** 성능을 높여준다.
- 동시성을 구현해도 설계는 변하지 않는다. -> 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.

### 동시성 방어 원칙

동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다. 즉, 동시성 관련 코드는 다른 코드와 분리해야 한다는 뜻이다.

### 실행 모델을 이해하라

|                             |                                                                                                                    |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| 한정된 자원(Bound Resource) | 다중 스레드 환경에서 사용하는 자원, 크기나 숫자가 제한적. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예. |
| 상호 배제(Mutual Exclusion) | 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우.                                                   |
| 기아(Starvation)            | 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다림.                                               |
| 데드락(Deadlock)            | 여러 스레드가 서로가 끝나기를 기다림.                                                                              |
| 라이브락(Livelock)          | 락을 거는 단계에서 각 스레드가 서로를 방해.                                                                        |

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다. 자바 언어는 개별 메서드를 보호하는 synchronized라는 개념을 지원한다.

공유 객체 하나에는 메서드 하나만 사용하라.

### 스레드 코드 테스트하기

문제를 노출하는 테스트 케이스를 작성하라. 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라. 테스트가 실패하면 원인을 추적하라. 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절대로 안 된다.

일회성 문제란 존재하지 않는다고 가정하자. 일회성 문제를 계속 무시한다면 잘못된 코드 위에 코드가 계속 쌓인다.

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라

- 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다.
- 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.
- 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다.
- 반복 테스트가 가능하도록 테스트 케이스를 작성한다.

# 중요하다고 생각하는 부분

**"테스트 함수마다 한 개념만 테스트하라."**  
**"개념 당 assert 문 수를 최소로 줄여라."**

SRP는 객체 지향 설계에서 중요한 개념이다. 또한 이해하고 지키기 수월한 개념이기도 하다. 하지만 이상하게도 SRP는 클래스 설계자가 가장 무시하는 규칙 중 하나다.

'처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다.

자신이 이해하는 코드를 짜기는 쉽다. 하지만 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성은 희박하다.

# 인사이트

테스트가 중요하다는 것을 알고는 있었지만 프로젝트에 적용해본 경험은 없었다. 작게라도 테스트 코드를 만들어보고 프로젝트를 보강해봐야겠다고 생각했다.

평소 다중 스레드를 고려하며 개발해본 경험이 없어서 낯설기도 했지만 스레드, 프로세스 등 잠깐 배웠던 개념들이 등장해서 반갑기도 했다. 스레드 관리가 어렵다는 것은 얼추 알고 있었지만 생각보다 고려할 점들이 더 많아서 개발할 때 까다롭겠다는 생각을 했다.
